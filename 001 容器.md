## 1. 顺序容器



## 2. 关联容器

### 2.1 set





## 3. 无序关联容器

### 3.1 unordered_map

**特性：**

- **底层实现**：`unordered_map` 使用**哈希表**（Hash Table）实现。
- **排序**：**元素不会根据键（key）进行排序**，而是根据键的哈希值组织到不同的“桶”中。因此，内部元素是无序的。
- **操作效率**：提供了平均情况下 **O(1)** 的查找、插入和删除操作效率，这在大多数情况下比 `std::map` 的 O(log n) 要快。但在最坏情况下（例如发生大量哈希冲突），性能会退化到 O(n)。

- **关联性**：通过 key 来访问元素，而不是位置（索引）。
- **唯一键**：容器中的每个键都是唯一的。如果插入一个已存在的键，新值会覆盖旧值（除非使用 `insert` 方法，该方法不会覆盖）。
- **键值对**：每个元素都是一个 `std::pair<const Key, T>` 对象。



**常规操作：**

**0. 声明和初始化**

```cpp
// 1. 空容器
unordered_map<string, int> umap;

// 2. 初始化列表 (C++11)
unordered_map<string, int> umap2 = {
    {"Alice", 25},
    {"Bob", 30},
    {"Charlie", 35}
};

// 3. 复制构造
unordered_map<string, int> umap3(umap2);
```



**1. 插入元素 (Insert)**

```cpp
// 使用 insert 方法 ( pair 或 make_pair )
umap.insert(std::pair<string, int>("David", 40));
umap.insert(std::make_pair("Eve", 45));

// 使用数组下标运算符 [] 
// 如果键不存在，会先创建该键并用默认值初始化（int 为 0），然后赋值。
umap["Frank"] = 50; // 最常用的方式

// 使用 emplace (C++11, 效率更高，直接在容器内构造对象，避免临时对象拷贝)
umap.emplace("Grace", 55);
```



**2. 访问元素 (Access)**

```cpp
// 使用下标运算符 []
// 注意：如果键不存在，会自动插入一个具有该键和默认值的元素！
int age = umap["Alice"]; // age = 25
int unknown = umap["Nobody"]; // "Nobody" 不存在，会被插入，unknown = 0

// 使用 at() 方法
// 如果键不存在，会抛出 std::out_of_range 异常。更安全。
try {
    int age2 = umap.at("Alice"); // age2 = 25
    int bad = umap.at("Ghost"); // 抛出异常
} catch (const std::out_of_range& e) {
    cout << "Key not found: " << e.what() << endl;
}

// 迭代器访问
for (auto it = umap.begin(); it != umap.end(); ++it) {
    // it->first 是 key, it->second 是 value
    cout << it->first << ": " << it->second << endl;
}

// 范围for循环 (C++11)
for (const auto& pair : umap) { // 使用 const & 避免拷贝
    cout << pair.first << ": " << pair.second << endl;
}
```



**3. 查找元素 (Find)**

```cpp
// 使用 find() 方法
// 如果找到，返回指向该元素的迭代器；否则返回 end()。
auto it = umap.find("Bob");
if (it != umap.end()) {
    cout << "Found: " << it->first << " -> " << it->second << endl;
} else {
    cout << "Not found" << endl;
}

// 使用 count() 方法
// 因为键唯一，返回值只能是 0 或 1。可以用来判断键是否存在。
if (umap.count("Bob") > 0) {
    cout << "Key exists" << endl;
}
```



**4. 删除元素 (Erase)**

```cpp
// 通过迭代器删除
auto it = umap.find("David");
if (it != umap.end()) {
    umap.erase(it);
}

// 通过键删除
size_t num_removed = umap.erase("Eve"); // 返回删除的元素个数 (0 或 1)

// 删除所有元素
// umap.clear();
```



**5. 容量查询**

```cpp
cout << "Size: " << umap.size() << endl;
cout << "Bucket count: " << umap.bucket_count() << endl; // 桶的数量
cout << "Load factor: " << umap.load_factor() << endl;   // 负载因子 (size / bucket_count)
cout << "Is empty? " << umap.empty() << endl;
```



**使用场景**

`unordered_map` 的核心优势是**快速的查找速度**。以下是一些典型的使用场景：

1. **缓存系统 (Cache)**：
   将计算结果（value）与输入参数（key）关联起来。当同样的参数再次请求时，可以先在 `unordered_map` 中查找是否已经计算过，避免重复计算。例如，Memoization 技术。

2. **频率统计**：
   统计一组数据中每个元素出现的次数。

   ```cpp
   vector<string> words = {"apple", "banana", "apple", "cherry"};
   unordered_map<string, int> wordCount;
   for (const auto& word : words) {
       wordCount[word]++; // 非常简洁高效
   }
   ```

   

3. **快速查找表**：
   当需要根据一个键快速查找对应的值，并且不关心元素的顺序时。例如：

   - 根据用户ID查找用户信息。
   - 根据单词查找其定义（字典）。
   - 根据产品编号查找产品价格。

4. **实现图结构 (Graph)**：
   图的邻接表表示法常用 `unordered_map` 来实现，其中键是节点，值是与该节点相连的节点列表。

   ```cpp
   unordered_map<int, vector<int>> graph; // 邻接表
   graph[1].push_back(2); // 节点 1 连接到节点 2
   graph[2].push_back(3);
   ```





### 3.2 